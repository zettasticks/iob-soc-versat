addressGen VLinear(xWidth){
   for x 0..xWidth
   addr = x;
}

addressGen VDouble(xWidth,yWidth,shift){
   for y 0..yWidth
   for x 0..xWidth
   addr = y * shift + x;
}

addressGen VTriple(xWidth,yWidth,zWidth,shift,shift2){
   for z 0..zWidth
   for y 0..yWidth
   for x 0..xWidth
   addr = x + shift * y + shift2 * z;
}

module EXAMPLE_Empty(){
#
}

module EXAMPLE_Simple(){
  Const a;
  Const b;
  Reg result;

#    
  addition = a + b;

  addition -> result;
}

addressGen Conv2D(kernelW,kernelH,inputImageW){
   for ky 0..kernelH
   for kx 0..kernelW
   addr = ky * inputImageW + kx;
}

addressGen Weight2D(kernelW,kernelH){
   for x 0..(kernelH*kernelW)
   addr = x;
}

addressGen SimpleOut(size,stride){
   for x 0..size
   addr = x / stride;
}

module EXAMPLE_Conv(){
   using(Conv2D) VRead features;
   using(Weight2D) VRead weights;
   F_Mul muller;
   MyFloatAccum myAccum;
   using(SimpleOut) VWrite output;
#   
   {features,weights} -> muller:0..1;
   muller -> myAccum;
   
   myAccum -> output;
}

module TestStaticChild2(){ // Since TestStaticChild2 is only used as static in the following modules, it should have the same values
   Const inside0; 
   static Const inside1;
#
   {inside0,inside1} -> out:0..1;
}

module TestStaticChild1() -> 3{
   static TestStaticChild2 child;
   Const inside; // Child1 differs only on the inside value, 3rd output
#
   {child:0..1,inside} -> out:0..2;
}

module CONFIG_SimpleStatic(){
   static Const inside[2]; // inside[0] and inside[1] should be different static instances. Changing one should not affect the other.
   TestStaticChild1 child[2]; // child[0] and child[1] should only differ in the third output.
   Reg output;
#
   a = inside[0] + inside[1] + child[0]:0 + child[0]:1 + child[0]:2 + child[1]:0 + child[1]:1 + child[1]:2;

   a -> output:0;
}

module CONFIG_OnlyStatic(){
   static Const unit;
   static Reg output;
#
   unit -> output;
}

module TestShareChild() -> 2{
   share(config) Const {
      x[2]; // x[0] and x[1] are equal
   }
   share(config) Const {
      y[2]; // y[0] and y[1] are equal
   }
#
   // a should equal b for all possible configurations
   a = x[0] + y[1]; 
   b = x[1] + y[0];

   {a,b} -> out:0..1;
}

module CONFIG_SimpleShare(){
   share(config) TestShareChild{
      childs[2];
   }
   Reg outputs[4];
#
   // Every single output should be equal
   childs[0]:0..1 -> outputs[0..1];
   childs[1]:0..1 -> outputs[2..3];
}

module CONFIG_PartialShare(){
   share(config) Const2(constant){
      units[2];
   }
   Reg outputs[4];
#
   units[0]:0..1 -> outputs[0..1];
   units[1]:0..1 -> outputs[2..3];
}

module CONFIG_PartialShare3Units(){
   share(config) Const2(constant){
      units[3];
   }
   Reg outputs[6];
#
   units[0]:0..1 -> outputs[0..1];
   units[1]:0..1 -> outputs[2..3];
   units[2]:0..1 -> outputs[4..5];
}

module CONFIG_PartialShareContained(){
   CONFIG_PartialShare shares[2];
#
}

module CONFIG_SharePartialContained(){
   share(config) CONFIG_PartialShare{
      shares[2];
   }
#
}

module CONFIG_SharePartialAndStaticSameModule(){
   share(config) Const2{
      consts[2];
   }
   static Const2 consts2;
   share(config) Const2(constant){
      consts3[2];
   }
   static Const2 consts4;

   Reg outputs[12];
#
   consts[0]:0..1 -> outputs[0..1];
   consts[1]:0..1 -> outputs[2..3];

   consts2:0..1 -> outputs[4..5];

   consts3[0]:0..1 -> outputs[6..7];
   consts3[1]:0..1 -> outputs[8..9];

   consts4:0..1 -> outputs[10..11];
}

module CONFIG_SharePartialAndStaticSameModuleContained(){
   CONFIG_SharePartialAndStaticSameModule container;
#   
}

module CONFIG_StaticContainsPartialShare(){
   static CONFIG_PartialShare unit;
#
}

module TestShareStaticChild() -> 2{
   static TestShareChild shareChild;
#
   shareChild:0..1 -> out:0..1;
}

module CONFIG_ShareStatic(){
   share(config) TestStaticChild1 {
      testShare[2]; // Should only share the Const inside
   }
   TestShareStaticChild testStatic[2];
   Reg outputs[10];
#
   {testShare[0]:0..2,testShare[1]:0..2,testStatic[0]:0..1,testStatic[1]:0..1} -> outputs[0..9];
}

module DELAYS_Variable(){
   Const constant;
   Buffer buf;
   Reg output;
#
   constant -> buf;
   buf -> output;
}

module DELAYS_AddedDelays(){
   Counter gen;
   Reg output;
#
   a = gen{1} + gen{2} + gen{3} + gen{4} + gen{5};

   a -> output;
}

module TestMergeChild1(){
   Const x;
   Const y;
   Reg output;
#
   a = x + y;
   a -> output;
}

module TestMergeChild2(){
   Const a;
   Const b;
   Reg output;
#
   x = a - b;
   x -> output;
}

module TestMergeChild3(){
   Const a;
   Const b;
   Reg output;
#
   x = a - b;
   x -> output;
}

merge MERGE_Simple = TestMergeChild1:w | TestMergeChild2:z{
   w.x - z.a;
   w.y - z.b;
   w.output - z.output;
}

module TestMergeInputs1(x,y){
#
   a = x + y;
   a -> out;
}

module TestMergeInputs2(a,b){
#
   x = a - b;
   x -> out;
}

merge MERGE_Inputs = TestMergeInputs1 | TestMergeInputs2;

module ModuleWithExtra(){
   Const a;
   Const b;
   MERGE_Inputs simple;
   Const c;
   Const d;
   Const e;
   Reg output;
#
   {a,b} -> simple:0..1;
   add = simple + c;
   add2 = d + e;
   add3 = add + add2;
   add3 -> output;
}

merge MergeTest = ModuleWithExtra | TestMergeInputs1;

module TestMergeNames1(){
   Const unit[2];
#
}

module TestMergeNames2(){
   Const unit;
#
}

merge MERGE_Names = TestMergeNames1 | TestMergeNames2;

module MERGE_SameTypeChildren(){
   MERGE_TwoLevels m[2];
#
}

module MERGE_ModuleWithMultipleMerged(){
   MERGE_Simple child0;
   MERGE_TwoLevels child1;
   MERGE_SameTypeChildren child2;
#
}

merge MERGE_HighComplexity = MERGE_ModuleWithMultipleMerged | MERGE_SameTypeChildren;

module TestMergeDelay1(){
   using(VLinear) Mem mem;
   Reg output;
#
   mem{3} -> output;
}

module TestMergeDelay2(){
   using(VLinear) Mem mem;
   Reg output;
#
   mem{5} -> output;
}

merge MERGE_Delays = TestMergeDelay1 | TestMergeDelay2;

module TestDoubleMerge00(){
   Const x00;
   Const y00;
#
   a = x00 + y00;
   a -> out;
}

module TestDoubleMerge01(){
   using(VLinear) Mem x01;
   using(VLinear) Mem y01;
#
   a = x01 + y01;
   a -> out;
}

module TestDoubleMerge10(){
   using(VLinear) Mem x10;
   Const y10;
#
   a = y10 - x10;
   a -> out;
}

module TestDoubleMerge11(){
   Const x11;
   using(VLinear) Mem y11;
#
   a = y11 - x11;
   a -> out;
}

merge TestDoubleMerge0 = TestDoubleMerge00 | TestDoubleMerge01;
merge TestDoubleMerge1 = TestDoubleMerge10 | TestDoubleMerge11;

merge MERGE_TwoLevels = TestDoubleMerge0 | TestDoubleMerge1;

module TestMergeStruct(){
   TestDoubleMerge0 d0;
   Const c;
#
   adder = d0 + c;
   adder -> out;
}

merge MERGE_MergeWithStructMerge = TestMergeStruct | TestDoubleMerge1;

module GraphLoop1(){
   Const const[3];
   Mul muller;
   Reg output;   
#
   {const[0],const[1]} -> muller:0..1;
   add = const[2] + muller;
   add -> output;
}

module GraphLoop2(){
   Mul muller;
   Const const[3];
   Reg output;   
#
   add = const[0] + const[1];
   {const[2],add} -> muller:0..1;
   muller -> output;
}

// Try to make the merged graph contain a loop.
// The loop should be muller -> adder -> muller
merge MERGE_GraphLoop = GraphLoop1 | GraphLoop2;

module DATABUS_SimpleTransfer(){
   using(VLinear) VRead read;
   using(VLinear) VWrite write;
#
   read -> write;
}

module DATABUS_MultipleTransfers(){
   using(VLinear,VDouble,VTriple) VRead read;
   using(VLinear,VDouble,VTriple) VWrite write;
#
   read -> write;
}

module MEM_SimpleTransfer(){
   using(VLinear) Mem start;
   using(VLinear) Mem end;
#
   start -> end;
}

module StaticMuladd(x,y){
   static Muladd mul;
#
   z = x + y;

   x -> mul:0;
   z -> mul:1;

   mul -> out;
}

// TODO: We might add this to the EXAMPLE tests
module StringHasher(){
   Const weight1;
   Const weight2;
   Const weight3;
   Const weight4;
   Const weight5;
   StaticMuladd mul1;
   StaticMuladd mul2;
   StaticMuladd mul3;
   StaticMuladd mul4;
   StaticMuladd mul5;
   Mem bytesIn;
   Mem bytesOut;
#
   bytesIn{0} -> mul1:0;
   bytesIn{1} -> mul2:0;
   bytesIn{2} -> mul3:0;
   bytesIn{3} -> mul4:0;
   bytesIn{4} -> mul5:0;

   weight1 -> mul1:1;
   weight2 -> mul2:1;
   weight3 -> mul3:1;
   weight4 -> mul4:1;
   weight5 -> mul5:1;

   a1 = mul1 + mul2;
   a2 = mul3 + mul4;
   a3 = a1 + a2;
   a4 = a3 + mul5;

   a4{1} -> bytesOut;
}

module sigma(x){
   Const const1;
   Const const2;
   Const const3;
#
   res = (x >>< const1) ^ (x >>< const2) ^ (x >> const3);
   res -> out;
}

module Sigma(x){
   Const const1;
   Const const2;
   Const const3;
#
   res = (x >>< const1) ^ (x >>< const2) ^ (x >>< const3);
   res -> out;
}

module CH(a,b,c){
#
   res = (a & b) ^ (~a & c);
   res -> out;
}

module Maj(x,y,z){
#
   res = (x & y) ^ (x & z) ^ (y & z);
   res -> out;
}

module sigma_stage(x,y){
   sigma sigma0;
   sigma sigma1;
#
   x -> sigma0;
   y -> sigma1;

   sigma0 -> out:0;
   sigma1 -> out:1;
}

module Comb_M_Stage(w0,w14,w9,w1){
   static sigma_stage sigma;
#
   w1 -> sigma:0;
   w14 -> sigma:1;
  
   res = sigma:0 + w0 + sigma:1 + w9;
   res -> out;
}

module EXAMPLE_M_Stage(w0,w14,w9,w1){
   Comb_M_Stage comb;
   PipelineRegister r;
#
   w0 -> comb:0;
   w14 -> comb:1;
   w9 -> comb:2;
   w1 -> comb:3;

   comb -> r;

   r -> out;
}

module M_Stage(w0,w14,w9,w1){
   Comb_M_Stage comb;
   PipelineRegister r;
#
   w0 -> comb:0;
   w14 -> comb:1;
   w9 -> comb:2;
   w1 -> comb:3;

   comb -> r;

   r -> out;
}

module M(w){
   M_Stage m0;
   M_Stage m1;
   M_Stage m2;
   M_Stage m3;
   M_Stage m4;
   M_Stage m5;
   M_Stage m6;
   M_Stage m7;
   M_Stage m8;
   M_Stage m9;
   M_Stage ma;
   M_Stage mb;
   M_Stage mc;
   M_Stage md;
   M_Stage me;
   M_Stage mf;
   Merge m;
#
   w{0} -> m0:0;
   w{14} -> m0:1;
   w{9} -> m0:2;
   w{1} -> m0:3;

   w{1} -> m1:0;
   w{15} -> m1:1;
   w{10} -> m1:2;
   w{2} -> m1:3;
   
   w{2} -> m2:0;
   m0 -> m2:1;
   w{11} -> m2:2;
   w{3} -> m2:3;
   
   w{3} -> m3:0;
   m1 -> m3:1;
   w{12} -> m3:2;
   w{4} -> m3:3;
   
   w{4} -> m4:0;
   m2 -> m4:1;
   w{13} -> m4:2;
   w{5} -> m4:3;
   
   w{5} -> m5:0;
   m3 -> m5:1;
   w{14} -> m5:2;
   w{6} -> m5:3;
   
   w{6} -> m6:0;
   m4 -> m6:1;
   w{15} -> m6:2;
   w{7} -> m6:3;
   
   w{7} -> m7:0;
   m5 -> m7:1;
   m0 -> m7:2;
   w{8} -> m7:3;
   
   w{8} -> m8:0;
   m6 -> m8:1;
   m1 -> m8:2;
   w{9} -> m8:3;
   
   w{9} -> m9:0;
   m7 -> m9:1;
   m2 -> m9:2;
   w{10} -> m9:3;
   
   w{10} -> ma:0;
   m8 -> ma:1;
   m3 -> ma:2;
   w{11} -> ma:3;
   
   w{11} -> mb:0;
   m9 -> mb:1;
   m4 -> mb:2;
   w{12} -> mb:3;
   
   w{12} -> mc:0;
   ma -> mc:1;
   m5 -> mc:2;
   w{13} -> mc:3;
   
   w{13} -> md:0;
   mb -> md:1;
   m6 -> md:2;
   w{14} -> md:3;
   
   w{14} -> me:0;
   mc -> me:1;
   m7 -> me:2;
   w{15} -> me:3;
   
   w{15} -> mf:0;
   md -> mf:1;
   m8 -> mf:2;
   m0 -> mf:3;

   m0 -> m:0;
   m1 -> m:1;
   m2 -> m:2;
   m3 -> m:3;
   m4 -> m:4;
   m5 -> m:5;
   m6 -> m:6;
   m7 -> m:7;
   m8 -> m:8;
   m9 -> m:9;
   ma -> m:10;
   mb -> m:11;
   mc -> m:12;
   md -> m:13;
   me -> m:14;
   mf -> m:15;

   m -> out;
}

module T1(e,f,g,h,k,w){
   CH ch;
   Sigma s;
#   
   e -> s;

   e -> ch:0;
   f -> ch:1;
   g -> ch:2;

   a1 = h + s:0;
   a2 = ch + k;
   a3 = a1 + a2;
   
   b1 = a3 + w;

   b1 -> out;
}

module T2(a,b,c){
   Sigma s;
   Maj m;
#
   a -> s;

   a -> m:0;
   b -> m:1;
   c -> m:2;

   d = s + m;

   d -> out; 
}

module T_Stage(a,b,c,e,f,g,h,k,w){
   T1 t1;
   T2 t2;
#
   a -> t2:0;
   b -> t2:1;
   c -> t2:2;

   e -> t1:0;
   f -> t1:1;
   g -> t1:2;
   h -> t1:3;
   k -> t1:4;
   w -> t1:5;

   t1 -> out:0;
   t2 -> out:1;
}

module Comb_F_Stage (a,b,c,d,e,f,g,h,k,w){
   static T_Stage t;
#
   a -> t:0;
   b -> t:1;
   c -> t:2;

   e -> t:3;
   f -> t:4;
   g -> t:5;
   h -> t:6;
   k -> t:7;
   w -> t:8;

   a1 = t:0 + t:1;
   a2 = d + t:0;

   a1 -> out:0;
   a  -> out:1;
   b  -> out:2;
   c  -> out:3;
   a2 -> out:4;
   e  -> out:5;
   f  -> out:6;
   g  -> out:7;
}

module EXAMPLE_F_Stage(a,b,c,d,e,f,g,h,k,w){
   Comb_F_Stage f_stage;
   PipelineRegister d[8];
#
   {a,b,c,d,e,f,g,h,k,w} -> f_stage:0..9;

   f_stage:0..7 -> d[0..7];

   d[0..7] -> out:0..7;
}

module F_Stage(a,b,c,d,e,f,g,h,k,w){
   Comb_F_Stage f_stage;
   PipelineRegister d[8];
#
   {a,b,c,d,e,f,g,h,k,w} -> f_stage:0..9;

   f_stage:0..7 -> d[0..7];

   d[0..7] -> out:0..7;
}

module F(a,b,c,d,e,f,g,h,k,w){
   F_Stage f0;
   F_Stage f1;
   F_Stage f2;
   F_Stage f3;
   F_Stage f4;
   F_Stage f5;
   F_Stage f6;
   F_Stage f7;
   F_Stage f8;
   F_Stage f9;
   F_Stage fa;
   F_Stage fb;
   F_Stage fc;
   F_Stage fd;
   F_Stage fe;
   F_Stage ff;
#
   a ->  f0:0;
   b ->  f0:1;
   c ->  f0:2;
   d ->  f0:3;
   e ->  f0:4;
   f ->  f0:5;
   g ->  f0:6;
   h ->  f0:7;
   k{0} -> f0:8;
   w{0} -> f0:9;

   f0:0..7 -> f1:0..7;
   k{1} -> f1:8;
   w{1} -> f1:9;

   f1:0..7 -> f2:0..7;
   k{2} -> f2:8;
   w{2} -> f2:9;

   f2:0..7 -> f3:0..7;
   k{3} -> f3:8;
   w{3} -> f3:9;

   f3:0..7 -> f4:0..7;
   k{4} -> f4:8;
   w{4} -> f4:9;

   f4:0..7 -> f5:0..7;
   k{5} -> f5:8;
   w{5} -> f5:9;

   f5:0..7 -> f6:0..7;
   k{6} -> f6:8;
   w{6} -> f6:9;

   f6:0..7 -> f7:0..7;
   k{7} -> f7:8;
   w{7} -> f7:9;

   f7:0..7 -> f8:0..7;
   k{8} -> f8:8;
   w{8} -> f8:9;

   f8:0..7 -> f9:0..7;
   k{9} -> f9:8;
   w{9} -> f9:9;

   f9:0..7 -> fa:0..7;
   k{10} -> fa:8;
   w{10} -> fa:9;

   fa:0..7 -> fb:0..7;
   k{11} -> fb:8;
   w{11} -> fb:9;

   fb:0..7 -> fc:0..7;
   k{12} -> fc:8;
   w{12} -> fc:9;

   fc:0..7 -> fd:0..7;
   k{13} -> fd:8;
   w{13} -> fd:9;

   fd:0..7 -> fe:0..7;
   k{14} -> fe:8;
   w{14} -> fe:9;

   fe:0..7 -> ff:0..7;
   k{15} -> ff:8;
   w{15} -> ff:9;

   ff:0..7 -> out:0..7;
}

module ShaSingleState(in){
   Reg reg;
#
   a = reg + in;
   a -> reg;
   reg -> out;
}

module GRAPH_SimpleLoop(in){
   Reg reg;
#
   a = reg + in;
   a -> reg;
   reg -> out;
}

// Simple grouping of state so it appears better on the graphs
module ShaState(x[8]){
   ShaSingleState s[8];
#
   x[0..7] -> s[0..7];
   s[0..7] -> out:0..7;
}

module Constants(){
   static OnlyOutputMem mem;
#
   mem -> out:0;
}

module EXAMPLE_SHA(){
   using(VLinear) VRead MemRead;
   SwapEndian Swap;
   xunitF F0;
   xunitF F1;
   xunitF F2;
   xunitF F3;
   xunitM M0;
   xunitM M1;
   xunitM M2;
   Constants cMem0;
   Constants cMem1;
   Constants cMem2;
   Constants cMem3;
   ShaState State;
#
   MemRead -> Swap;
   
   {State:0..7,cMem0,Swap} -> F0:0..9;
   {F0:0..7   ,cMem1,M0}   -> F1:0..9;
   {F1:0..7   ,cMem2,M1}   -> F2:0..9;
   {F2:0..7   ,cMem3,M2}   -> F3:0..9;

   Swap -> M0;
   M0 -> M1;
   M1 -> M2;
   
   F3:0..7 -> State:0..7;
}

module SBoxGroup(x[16]){
   SBox box[16];
#
   x[0..15] -> box[0..15];
   box[0..15] -> out:0..15;
}

module RSBoxGroup(x[16]){
   RSBox box[16];
#
   x[0..15] -> box[0..15];
   box[0..15] -> out:0..15;
}

module ShiftRows(x[16]){
#
   // First row
   {x[0],x[4],x[8],x[12]} -> {out:0,out:4,out:8,out:12};

   // Second row
   {x[1],x[5],x[9],x[13]} -> {out:13,out:1,out:5,out:9};

   // Third row
   {x[2],x[6],x[10],x[14]} -> {out:10,out:14,out:2,out:6};

   // Fourth row
   {x[3],x[7],x[11],x[15]} -> {out:7,out:11,out:15,out:3};
}

module InvShiftRows(x[16]){
#
   // First row
   {x[0],x[4],x[8],x[12]} -> {out:0,out:4,out:8,out:12};

   // Second row
   {x[1],x[5],x[9],x[13]} -> {out:5,out:9,out:13,out:1};

   // Third row
   {x[2],x[6],x[10],x[14]} -> {out:10,out:14,out:2,out:6};

   // Fourth row
   {x[3],x[7],x[11],x[15]} -> {out:15,out:3,out:7,out:11};
}

module InvDoRow(x[4]){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul9[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul11[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul13[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul14[2];
#
   // "Multiple" (lookup) each by 9,11,13,14
   x[0..3] -> { mul9[0]:0..1, mul9[1]:0..1};
   x[0..3] -> {mul11[0]:0..1,mul11[1]:0..1};
   x[0..3] -> {mul13[0]:0..1,mul13[1]:0..1};
   x[0..3] -> {mul14[0]:0..1,mul14[1]:0..1};

   r0 = mul14[0] ^ mul11[0]:1 ^ mul13[1] ^  mul9[1]:1;
   r1 =  mul9[0] ^ mul14[0]:1 ^ mul11[1] ^ mul13[1]:1;
   r2 = mul13[0] ^  mul9[0]:1 ^ mul14[1] ^ mul11[1]:1;
   r3 = mul11[0] ^ mul13[0]:1 ^  mul9[1] ^ mul14[1]:1;

   {r0,r1,r2,r3} -> out:0..3;
}

module DoRow(x[4]){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul2[2];
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) mul3[2];
#
   // "Multiple" (lookup) each by 2 and by 3
   x[0..3] -> {mul2[0]:0..1,mul2[1]:0..1};
   x[0..3] -> {mul3[0]:0..1,mul3[1]:0..1};

   r0 = x[2] ^ x[3] ^ mul2[0]   ^ mul3[0]:1;
   r1 = x[0] ^ x[3] ^ mul2[0]:1 ^ mul3[1] ;
   r2 = x[0] ^ x[1] ^ mul2[1]   ^ mul3[1]:1;
   r3 = x[1] ^ x[2] ^ mul2[1]:1 ^ mul3[0];

   {r0,r1,r2,r3} -> out:0..3;
}

module MixColumns(x[16]){
   DoRow d[4];
#
   {x[0],x[1],x[2],x[3]}  -> d[0]:0..3;
   {x[4],x[5],x[6],x[7]}  -> d[1]:0..3;
   {x[8],x[9],x[10],x[11]} -> d[2]:0..3;
   {x[12],x[13],x[14],x[15]} -> d[3]:0..3;

   d[0]:0..3 -> {out:0,out:1,out:2,out:3};
   d[1]:0..3 -> {out:4,out:5,out:6,out:7};
   d[2]:0..3 -> {out:8,out:9,out:10,out:11};
   d[3]:0..3 -> {out:12,out:13,out:14,out:15};
}

module InvMixColumns(x[16]){
   InvDoRow d[4];
#
   {x[0],x[1],x[2],x[3]}  -> d[0]:0..3;
   {x[4],x[5],x[6],x[7]}  -> d[1]:0..3;
   {x[8],x[9],x[10],x[11]} -> d[2]:0..3;
   {x[12],x[13],x[14],x[15]} -> d[3]:0..3;

   d[0]:0..3 -> {out:0,out:1,out:2,out:3};
   d[1]:0..3 -> {out:4,out:5,out:6,out:7};
   d[2]:0..3 -> {out:8,out:9,out:10,out:11};
   d[3]:0..3 -> {out:12,out:13,out:14,out:15};
}

module EXAMPLE_AddRoundKey(x[16],y[16]){
#
   a[0] = x[0] ^ y[0];
   a[1] = x[1] ^ y[1];
   a[2] = x[2] ^ y[2];
   a[3] = x[3] ^ y[3];
   a[4] = x[4] ^ y[4];
   a[5] = x[5] ^ y[5];
   a[6] = x[6] ^ y[6];
   a[7] = x[7] ^ y[7];
   a[8] = x[8] ^ y[8];
   a[9] = x[9] ^ y[9];
   a[10] = x[10] ^ y[10];
   a[11] = x[11] ^ y[11];
   a[12] = x[12] ^ y[12];
   a[13] = x[13] ^ y[13];
   a[14] = x[14] ^ y[14];
   a[15] = x[15] ^ y[15];

   a[0..15] -> out:0..15;
}

module AddRoundKey(x[16],y[16]){
#
   a[0] = x[0] ^ y[0];
   a[1] = x[1] ^ y[1];
   a[2] = x[2] ^ y[2];
   a[3] = x[3] ^ y[3];
   a[4] = x[4] ^ y[4];
   a[5] = x[5] ^ y[5];
   a[6] = x[6] ^ y[6];
   a[7] = x[7] ^ y[7];
   a[8] = x[8] ^ y[8];
   a[9] = x[9] ^ y[9];
   a[10] = x[10] ^ y[10];
   a[11] = x[11] ^ y[11];
   a[12] = x[12] ^ y[12];
   a[13] = x[13] ^ y[13];
   a[14] = x[14] ^ y[14];
   a[15] = x[15] ^ y[15];

   a[0..15] -> out:0..15;
}

module FirstLineKey(x[4],w[4],rcon){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) b[2];
#
   {x[1],x[2],x[3],x[0]} -> {b[0]:0..1,b[1]:0..1};

   d[0] = b[0]:0 ^ w[0] ^ rcon;
   d[1] = b[0]:1 ^ w[1];
   d[2] = b[1]:0 ^ w[2];
   d[3] = b[1]:1 ^ w[3];

   d[0..3] -> out:0..3;
}

module FourthLineKey(x[4],w[4]){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) b[2];
#
   {x[0..1],x[2..3]} -> {b[0]:0..1,b[1]:0..1};

   d[0] = b[0]:0 ^ w[0];
   d[1] = b[0]:1 ^ w[1];
   d[2] = b[1]:0 ^ w[2];
   d[3] = b[1]:1 ^ w[3];

   d[0..3] -> out:0..3; 
}

module KeySchedule(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,xa,xb,xc,xd,xe,xf,rcon){
   FirstLineKey s;
#
   x3 -> s:0;
   x7 -> s:1;
   xb -> s:2;
   xf -> s:3;
   x0 -> s:4;
   x4 -> s:5;
   x8 -> s:6;
   xc -> s:7;
   rcon -> s:8;

   a0 = s:0 ^ x1;
   a1 = s:1 ^ x5;
   a2 = s:2 ^ x9;
   a3 = s:3 ^ xd;

   b0 = a0 ^ x2;
   b1 = a1 ^ x6;
   b2 = a2 ^ xa;
   b3 = a3 ^ xe;

   c0 = b0 ^ x3;
   c1 = b1 ^ x7;
   c2 = b2 ^ xb;
   c3 = b3 ^ xf;

   s:0 -> out:0;
   s:1 -> out:4;
   s:2 -> out:8;
   s:3 -> out:12;
   a0 -> out:1;
   a1 -> out:5;
   a2 -> out:9;
   a3 -> out:13;
   b0 -> out:2;
   b1 -> out:6;
   b2 -> out:10;
   b3 -> out:14;
   c0 -> out:3;
   c1 -> out:7;
   c2 -> out:11;
   c3 -> out:15;
}

module KeySchedule256(x[32],rcon){
   FirstLineKey s;
   FourthLineKey q;
#
   {x[19],x[23],x[27],x[31]} -> s:0..3;
   {x[0],x[4],x[8],x[12]}    -> s:4..7;
   rcon -> s:8;

   a[0] = s:0 ^ x[1];
   a[1] = s:1 ^ x[5];
   a[2] = s:2 ^ x[9];
   a[3] = s:3 ^ x[13];

   b[0] = a[0] ^ x[2];
   b[1] = a[1] ^ x[6];
   b[2] = a[2] ^ x[10];
   b[3] = a[3] ^ x[14];

   c[0] = b[0] ^ x[3];
   c[1] = b[1] ^ x[7];
   c[2] = b[2] ^ x[11];
   c[3] = b[3] ^ x[15];

   c[0..3] -> q:0..3;

   {x[16],x[20],x[24],x[28]} -> q:4..7;

   d[0] = q:0 ^ x[17];
   d[1] = q:1 ^ x[21];
   d[2] = q:2 ^ x[25];
   d[3] = q:3 ^ x[29];

   e[0] = d[0] ^ x[18];
   e[1] = d[1] ^ x[22];
   e[2] = d[2] ^ x[26];
   e[3] = d[3] ^ x[30];

   f[0] = e[0] ^ x[19];
   f[1] = e[1] ^ x[23];
   f[2] = e[2] ^ x[27];
   f[3] = e[3] ^ x[31];

   s:0..3  -> {out:0,out:4,out:8,out:12};
   a[0..3] -> {out:1,out:5,out:9,out:13};
   b[0..3] -> {out:2,out:6,out:10,out:14};
   c[0..3] -> {out:3,out:7,out:11,out:15};

   q:0..3  -> {out:16,out:20,out:24,out:28};
   d[0..3] -> {out:17,out:21,out:25,out:29};
   e[0..3] -> {out:18,out:22,out:26,out:30};
   f[0..3] -> {out:19,out:23,out:27,out:31};
}

module HierExample(x,y){
#
   add = x + y;
   sub = x - y;

   add -> out:0;
   sub -> out:1;
}

module HierUseExample(){
   Const c0;
   Const c1;
   HierExample ex;
   Store s0;
   Store s1;
#
   c0 -> ex:0;
   c1 -> ex:1;

   ex:0 -> s0;
   ex:1 -> s1;
}

module FixedAverage(){
   Mem mem;
   Store output;
#
   sum = mem{0} + mem{1} + mem{2} + mem{3};
   average = sum >> 2;

   average -> output;
}

module UNIT_LookupTable(){
   Const input[2];
   Reg output[2];
   LookupTable table;
#
   input[0..1] -> table:0..1;
   table:0..1 -> output[0..1];
}

module F2(a,b,c,d,e,f,g,h,k,w){
   F_Stage f0;
   F_Stage f1;
#
   a ->  f0:0;
   b ->  f0:1;
   c ->  f0:2;
   d ->  f0:3;
   e ->  f0:4;
   f ->  f0:5;
   g ->  f0:6;
   h ->  f0:7;
   k{0} -> f0:8;
   w{0} -> f0:9;

   f0:0..7 -> f1:0..7;
   k{1} -> f1:8;
   w{1} -> f1:9;

   f1:0..7 -> out:0..7;
}

module M2(w){
   M_Stage m0;
   M_Stage m1;
   Merge m;
#
   w{0} -> m0:0;
   w{14} -> m0:1;
   w{9} -> m0:2;
   w{1} -> m0:3;

   w{1} -> m1:0;
   w{15} -> m1:1;
   w{10} -> m1:2;
   w{2} -> m1:3;

   m0 -> m:0;
   m1 -> m:1;

   m -> out;
}

module Karatsuba(x1,x0,y1,y0){
   Mul z0;
   Mul mul;
   Mul z2;
#
   x0 -> z0:0;
   y0 -> z0:1;   

   x1 -> z2:0;
   y1 -> z2:1;

   fullX = x1 + x0;
   fullY = y1 + y0;

   fullX -> mul:0;
   fullY -> mul:1;   

   a = mul - z2;
   b = a - z0;

   b -> out;
}

module M4(w){
   M_Stage m0;
   M_Stage m1;
   M_Stage m2;
   M_Stage m3;
   Merge m;
#
   w{0} -> m0:0;
   w{14} -> m0:1;
   w{9} -> m0:2;
   w{1} -> m0:3;

   w{1} -> m1:0;
   w{15} -> m1:1;
   w{10} -> m1:2;
   w{2} -> m1:3;
   
   w{2} -> m2:0;
   m0 -> m2:1;
   w{11} -> m2:2;
   w{3} -> m2:3;
   
   w{3} -> m3:0;
   m1 -> m3:1;
   w{12} -> m3:2;
   w{4} -> m3:3;
   
   m0 -> m:0;
   m1 -> m:1;
   m2 -> m:2;
   m3 -> m:3;

   m -> out;
}

module M8(w){
   M_Stage m0;
   M_Stage m1;
   M_Stage m2;
   M_Stage m3;
   M_Stage m4;
   M_Stage m5;
   M_Stage m6;
   M_Stage m7;
   Merge m;
#
   w{0} -> m0:0;
   w{14} -> m0:1;
   w{9} -> m0:2;
   w{1} -> m0:3;

   w{1} -> m1:0;
   w{15} -> m1:1;
   w{10} -> m1:2;
   w{2} -> m1:3;
   
   w{2} -> m2:0;
   m0 -> m2:1;
   w{11} -> m2:2;
   w{3} -> m2:3;
   
   w{3} -> m3:0;
   m1 -> m3:1;
   w{12} -> m3:2;
   w{4} -> m3:3;
   
   w{4} -> m4:0;
   m2 -> m4:1;
   w{13} -> m4:2;
   w{5} -> m4:3;
   
   w{5} -> m5:0;
   m3 -> m5:1;
   w{14} -> m5:2;
   w{6} -> m5:3;
   
   w{6} -> m6:0;
   m4 -> m6:1;
   w{15} -> m6:2;
   w{7} -> m6:3;
   
   w{7} -> m7:0;
   m5 -> m7:1;
   m0 -> m7:2;
   w{8} -> m7:3;
   
   m0 -> m:0;
   m1 -> m:1;
   m2 -> m:2;
   m3 -> m:3;
   m4 -> m:4;
   m5 -> m:5;
   m6 -> m:6;
   m7 -> m:7;

   m -> out;
}

module F8(a,b,c,d,e,f,g,h,k,w){
   F_Stage f0;
   F_Stage f1;
   F_Stage f2;
   F_Stage f3;
   F_Stage f4;
   F_Stage f5;
   F_Stage f6;
   F_Stage f7;
#
   a ->  f0:0;
   b ->  f0:1;
   c ->  f0:2;
   d ->  f0:3;
   e ->  f0:4;
   f ->  f0:5;
   g ->  f0:6;
   h ->  f0:7;
   k{0} -> f0:8;
   w{0} -> f0:9;

   f0:0..7 -> f1:0..7;
   k{1} -> f1:8;
   w{1} -> f1:9;

   f1:0..7 -> f2:0..7;
   k{2} -> f2:8;
   w{2} -> f2:9;

   f2:0..7 -> f3:0..7;
   k{3} -> f3:8;
   w{3} -> f3:9;

   f3:0..7 -> f4:0..7;
   k{4} -> f4:8;
   w{4} -> f4:9;

   f4:0..7 -> f5:0..7;
   k{5} -> f5:8;
   w{5} -> f5:9;

   f5:0..7 -> f6:0..7;
   k{6} -> f6:8;
   w{6} -> f6:9;

   f6:0..7 -> f7:0..7;
   k{7} -> f7:8;
   w{7} -> f7:9;

   f7:0..7 -> out:0..7;
}

module F4(a,b,c,d,e,f,g,h,k,w){
   F_Stage f0;
   F_Stage f1;
   F_Stage f2;
   F_Stage f3;
#
   a ->  f0:0;
   b ->  f0:1;
   c ->  f0:2;
   d ->  f0:3;
   e ->  f0:4;
   f ->  f0:5;
   g ->  f0:6;
   h ->  f0:7;
   k{0} -> f0:8;
   w{0} -> f0:9;

   f0:0..7 -> f1:0..7;
   k{1} -> f1:8;
   w{1} -> f1:9;

   f1:0..7 -> f2:0..7;
   k{2} -> f2:8;
   w{2} -> f2:9;

   f2:0..7 -> f3:0..7;
   k{3} -> f3:8;
   w{3} -> f3:9;

   f3:0..7 -> out:0..7;
}

module A(x,y,z){
   Mul mul;
#
   x -> mul:0;
   z -> mul:1;

   add = mul + y;

   add -> out;
}

module B(x,y){
#
   add = x + y;
   add -> out;
}

module TestConfigOrder(){
   Mem store;
   Const a1;
# 
   b = 5;
   b -> store;
}

module VectorLikeOperation(){
   ReadWriteMem mat;
   VRead row;
   VWrite writer;
   Const mask;
#
   a = row & mask;
   b = mat ^ a;

   c = mat & mask;
   d = row ^ c;

   b -> mat;
   d -> writer;
}

module KeccakF1600(Aba,Abe,Abi,Abo,Abu,Aga,Age,Agi,Ago,Agu,Aka,Ake,Aki,Ako,Aku,Ama,Ame,Ami,Amo,Amu,Asa,Ase,Asi,Aso,Asu){
   Const roundConst0;
   Const roundConst1;
#
   BCa = Aba ^ Aga ^ Aka ^ Ama ^ Asa;
   BCe = Abe ^ Age ^ Ake ^ Ame ^ Ase;
   BCi = Abi ^ Agi ^ Aki ^ Ami ^ Asi;
   BCo = Abo ^ Ago ^ Ako ^ Amo ^ Aso;
   BCu = Abu ^ Agu ^ Aku ^ Amu ^ Asu;

   Da = BCu ^ (BCe ><< 1);
   De = BCa ^ (BCi ><< 1);
   Di = BCe ^ (BCo ><< 1);
   Do = BCi ^ (BCu ><< 1);
   Du = BCo ^ (BCa ><< 1);

   Aba ^= Da;
   BCa = Aba;
   Age ^= De;
   BCe = Age ><< 44;
   Aki ^= Di;
   BCi = Aki ><< 43;
   Amo ^= Do;
   BCo = Amo ><< 21;
   Asu ^= Du;
   BCu = Asu ><< 14;
   Eba = BCa ^ ((~BCe) & BCi);
   Eba ^= roundConst0;
   Ebe = BCe ^ ((~BCi) & BCo);
   Ebi = BCi ^ ((~BCo) & BCu);
   Ebo = BCo ^ ((~BCu) & BCa);
   Ebu = BCu ^ ((~BCa) & BCe);

   Abo ^= Do;
   BCa = Abo ><< 28;
   Agu ^= Du;
   BCe = Agu ><< 20;
   Aka ^= Da;
   BCi = Aka ><< 3;
   Ame ^= De;
   BCo = Ame ><< 45;
   Asi ^= Di;
   BCu = Asi ><< 61;
   Ega = BCa ^ ((~BCe) & BCi);
   Ege = BCe ^ ((~BCi) & BCo);
   Egi = BCi ^ ((~BCo) & BCu);
   Ego = BCo ^ ((~BCu) & BCa);
   Egu = BCu ^ ((~BCa) & BCe);

   Abe ^= De;
   BCa = Abe ><< 1;
   Agi ^= Di;
   BCe = Agi ><< 6;
   Ako ^= Do;
   BCi = Ako ><< 25;
   Amu ^= Du;
   BCo = Amu ><< 8;
   Asa ^= Da;
   BCu = Asa ><< 18;
   Eka = BCa ^ ((~BCe) & BCi);
   Eke = BCe ^ ((~BCi) & BCo);
   Eki = BCi ^ ((~BCo) & BCu);
   Eko = BCo ^ ((~BCu) & BCa);
   Eku = BCu ^ ((~BCa) & BCe);

   Abu ^= Du;
   BCa = Abu ><< 27;
   Aga ^= Da;
   BCe = Aga ><< 36;
   Ake ^= De;
   BCi = Ake ><< 10;
   Ami ^= Di;
   BCo = Ami ><< 15;
   Aso ^= Do;
   BCu = Aso ><< 56;
   Ema = BCa ^ ((~BCe) & BCi);
   Eme = BCe ^ ((~BCi) & BCo);
   Emi = BCi ^ ((~BCo) & BCu);
   Emo = BCo ^ ((~BCu) & BCa);
   Emu = BCu ^ ((~BCa) & BCe);

   Abi ^= Di;
   BCa = Abi ><< 62;
   Ago ^= Do;
   BCe = Ago ><< 55;
   Aku ^= Du;
   BCi = Aku ><< 39;
   Ama ^= Da;
   BCo = Ama ><< 41;
   Ase ^= De;
   BCu = Ase ><< 2;
   Esa = BCa ^ ((~BCe) & BCi);
   Ese = BCe ^ ((~BCi) & BCo);
   Esi = BCi ^ ((~BCo) & BCu);
   Eso = BCo ^ ((~BCu) & BCa);
   Esu = BCu ^ ((~BCa) & BCe);

   BCa = Eba ^ Ega ^ Eka ^ Ema ^ Esa;
   BCe = Ebe ^ Ege ^ Eke ^ Eme ^ Ese;
   BCi = Ebi ^ Egi ^ Eki ^ Emi ^ Esi;
   BCo = Ebo ^ Ego ^ Eko ^ Emo ^ Eso;
   BCu = Ebu ^ Egu ^ Eku ^ Emu ^ Esu;

   Da = BCu ^ BCe ><< 1;
   De = BCa ^ BCi ><< 1;
   Di = BCe ^ BCo ><< 1;
   Do = BCi ^ BCu ><< 1;
   Du = BCo ^ BCa ><< 1;

   Eba ^= Da;
   BCa = Eba;
   Ege ^= De;
   BCe = Ege ><< 44;
   Eki ^= Di;
   BCi = Eki ><< 43;
   Emo ^= Do;
   BCo = Emo ><< 21;
   Esu ^= Du;
   BCu = Esu ><< 14;
   Aba = BCa ^ ((~BCe) & BCi);
   Aba ^= roundConst1;
   Abe = BCe ^ ((~BCi) & BCo);
   Abi = BCi ^ ((~BCo) & BCu);
   Abo = BCo ^ ((~BCu) & BCa);
   Abu = BCu ^ ((~BCa) & BCe);

   Ebo ^= Do;
   BCa = Ebo ><< 28;
   Egu ^= Du;
   BCe = Egu ><< 20;
   Eka ^= Da;
   BCi = Eka ><< 3;
   Eme ^= De;
   BCo = Eme ><< 45;
   Esi ^= Di;
   BCu = Esi ><< 61;
   Aga = BCa ^ ((~BCe) & BCi);
   Age = BCe ^ ((~BCi) & BCo);
   Agi = BCi ^ ((~BCo) & BCu);
   Ago = BCo ^ ((~BCu) & BCa);
   Agu = BCu ^ ((~BCa) & BCe);

   Ebe ^= De;
   BCa = Ebe ><< 1;
   Egi ^= Di;
   BCe = Egi ><< 6;
   Eko ^= Do;
   BCi = Eko ><< 25;
   Emu ^= Du;
   BCo = Emu ><< 8;
   Esa ^= Da;
   BCu = Esa ><< 18;
   Aka = BCa ^ ((~BCe) & BCi);
   Ake = BCe ^ ((~BCi) & BCo);
   Aki = BCi ^ ((~BCo) & BCu);
   Ako = BCo ^ ((~BCu) & BCa);
   Aku = BCu ^ ((~BCa) & BCe);

   Ebu ^= Du;
   BCa = Ebu ><< 27;
   Ega ^= Da;
   BCe = Ega ><< 36;
   Eke ^= De;
   BCi = Eke ><< 10;
   Emi ^= Di;
   BCo = Emi ><< 15;
   Eso ^= Do;
   BCu = Eso ><< 56;
   Ama = BCa ^ ((~BCe) & BCi);
   Ame = BCe ^ ((~BCi) & BCo);
   Ami = BCi ^ ((~BCo) & BCu);
   Amo = BCo ^ ((~BCu) & BCa);
   Amu = BCu ^ ((~BCa) & BCe);

   Ebi ^= Di;
   BCa = Ebi ><< 62;
   Ego ^= Do;
   BCe = Ego ><< 55;
   Eku ^= Du;
   BCi = Eku ><< 39;
   Ema ^= Da;
   BCo = Ema ><< 41;
   Ese ^= De;
   BCu = Ese ><< 2;
   Asa = BCa ^ ((~BCe) & BCi);
   Ase = BCe ^ ((~BCi) & BCo);
   Asi = BCi ^ ((~BCo) & BCu);
   Aso = BCo ^ ((~BCu) & BCa);
   Asu = BCu ^ ((~BCa) & BCe);

   Aba -> out:0;
   Abe -> out:1;
   Abi -> out:2;
   Abo -> out:3;
   Abu -> out:4;
   Aga -> out:5;
   Age -> out:6;
   Agi -> out:7;
   Ago -> out:8;
   Agu -> out:9;
   Aka -> out:10;
   Ake -> out:11;
   Aki -> out:12;
   Ako -> out:13;
   Aku -> out:14;
   Ama -> out:15;
   Ame -> out:16;
   Ami -> out:17;
   Amo -> out:18;
   Amu -> out:19;
   Asa -> out:20;
   Ase -> out:21;
   Asi -> out:22;
   Aso -> out:23;
   Asu -> out:24;
}

module DoubleKeccak24Round(Aba,Abe,Abi,Abo,Abu,Aga,Age,Agi,Ago,Agu,Aka,Ake,Aki,Ako,Aku,Ama,Ame,Ami,Amo,Amu,Asa,Ase,Asi,Aso,Asu){
   KeccakF1600 d0;
   KeccakF1600 d1;
#
   Aba -> d0:0;
   Abe -> d0:1;
   Abi -> d0:2;
   Abo -> d0:3;
   Abu -> d0:4;
   Aga -> d0:5;
   Age -> d0:6;
   Agi -> d0:7;
   Ago -> d0:8;
   Agu -> d0:9;
   Aka -> d0:10;
   Ake -> d0:11;
   Aki -> d0:12;
   Ako -> d0:13;
   Aku -> d0:14;
   Ama -> d0:15;
   Ame -> d0:16;
   Ami -> d0:17;
   Amo -> d0:18;
   Amu -> d0:19;
   Asa -> d0:20;
   Ase -> d0:21;
   Asi -> d0:22;
   Aso -> d0:23;
   Asu -> d0:24;

   d0:0..23 -> d1:0..23;

   d1 -> out:0;
   d1 -> out:1;
   d1 -> out:2;
   d1 -> out:3;
   d1 -> out:4;
   d1 -> out:5;
   d1 -> out:6;
   d1 -> out:7;
   d1 -> out:8;
   d1 -> out:9;
   d1 -> out:10;
   d1 -> out:11;
   d1 -> out:12;
   d1 -> out:13;
   d1 -> out:14;
   d1 -> out:15;
   d1 -> out:16;
   d1 -> out:17;
   d1 -> out:18;
   d1 -> out:19;
   d1 -> out:20;
   d1 -> out:21;
   d1 -> out:22;
   d1 -> out:23;
   d1 -> out:24;
}

module Keccak16Rounds(Aba,Abe,Abi,Abo,Abu,Aga,Age,Agi,Ago,Agu,Aka,Ake,Aki,Ako,Aku,Ama,Ame,Ami,Amo,Amu,Asa,Ase,Asi,Aso,Asu){
   DoubleKeccak24Round d0;
   DoubleKeccak24Round d1;
   DoubleKeccak24Round d2;
   DoubleKeccak24Round d3;
#
   Aba -> d0:0;
   Abe -> d0:1;
   Abi -> d0:2;
   Abo -> d0:3;
   Abu -> d0:4;
   Aga -> d0:5;
   Age -> d0:6;
   Agi -> d0:7;
   Ago -> d0:8;
   Agu -> d0:9;
   Aka -> d0:10;
   Ake -> d0:11;
   Aki -> d0:12;
   Ako -> d0:13;
   Aku -> d0:14;
   Ama -> d0:15;
   Ame -> d0:16;
   Ami -> d0:17;
   Amo -> d0:18;
   Amu -> d0:19;
   Asa -> d0:20;
   Ase -> d0:21;
   Asi -> d0:22;
   Aso -> d0:23;
   Asu -> d0:24;

   d0 -> d1;
   d1 -> d2;
   d2 -> d3;

   d3 -> out:0;
   d3 -> out:1;
   d3 -> out:2;
   d3 -> out:3;
   d3 -> out:4;
   d3 -> out:5;
   d3 -> out:6;
   d3 -> out:7;
   d3 -> out:8;
   d3 -> out:9;
   d3 -> out:10;
   d3 -> out:11;
   d3 -> out:12;
   d3 -> out:13;
   d3 -> out:14;
   d3 -> out:15;
   d3 -> out:16;
   d3 -> out:17;
   d3 -> out:18;
   d3 -> out:19;
   d3 -> out:20;
   d3 -> out:21;
   d3 -> out:22;
   d3 -> out:23;
   d3 -> out:24;
}

module Keccak24Rounds(Aba,Abe,Abi,Abo,Abu,Aga,Age,Agi,Ago,Agu,Aka,Ake,Aki,Ako,Aku,Ama,Ame,Ami,Amo,Amu,Asa,Ase,Asi,Aso,Asu){
   DoubleKeccak24Round d0;
   DoubleKeccak24Round d1;
   DoubleKeccak24Round d2;
   DoubleKeccak24Round d3;
   DoubleKeccak24Round d4;
   DoubleKeccak24Round d5;
#
   Aba -> d0:0;
   Abe -> d0:1;
   Abi -> d0:2;
   Abo -> d0:3;
   Abu -> d0:4;
   Aga -> d0:5;
   Age -> d0:6;
   Agi -> d0:7;
   Ago -> d0:8;
   Agu -> d0:9;
   Aka -> d0:10;
   Ake -> d0:11;
   Aki -> d0:12;
   Ako -> d0:13;
   Aku -> d0:14;
   Ama -> d0:15;
   Ame -> d0:16;
   Ami -> d0:17;
   Amo -> d0:18;
   Amu -> d0:19;
   Asa -> d0:20;
   Ase -> d0:21;
   Asi -> d0:22;
   Aso -> d0:23;
   Asu -> d0:24;

   d0 -> d1;
   d1 -> d2;
   d2 -> d3;
   d3 -> d4;
   d4 -> d5;

   d5 -> out:0;
   d5 -> out:1;
   d5 -> out:2;
   d5 -> out:3;
   d5 -> out:4;
   d5 -> out:5;
   d5 -> out:6;
   d5 -> out:7;
   d5 -> out:8;
   d5 -> out:9;
   d5 -> out:10;
   d5 -> out:11;
   d5 -> out:12;
   d5 -> out:13;
   d5 -> out:14;
   d5 -> out:15;
   d5 -> out:16;
   d5 -> out:17;
   d5 -> out:18;
   d5 -> out:19;
   d5 -> out:20;
   d5 -> out:21;
   d5 -> out:22;
   d5 -> out:23;
   d5 -> out:24;
}

module Blake2G(a,b,c,d,m0,m1){
#
   a = a + b + m0;
   d = (d ^ a) ><< 16;
   c = c + d;
   b = (b ^ c) ><< 12;
   a = a + b + m1;
   d = (d ^ a) ><< 8;
   c = c + d;
   b = (b ^ c) ><< 7;

   a -> out:0;
   b -> out:1;
   c -> out:2;
   d -> out:3;
}

module Blake2Round(v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15){
   Mem m;
   Blake2G g0;
   Blake2G g1;
   Blake2G g2;
   Blake2G g3;
   Blake2G g4;
   Blake2G g5;
   Blake2G g6;
   Blake2G g7;
#
   v0   -> g0:0;
   v4   -> g0:1;
   v8   -> g0:2;
   v12  -> g0:3;
   m{0} -> g0:4;
   m{1} -> g0:5;

   v1   -> g1:0;
   v5   -> g1:1;
   v9   -> g1:2;
   v13  -> g1:3;
   m{2} -> g1:4;
   m{3} -> g1:5;

   v2   -> g2:0;
   v6   -> g2:1;
   v10  -> g2:2;
   v14  -> g2:3;
   m{4} -> g2:4;
   m{5} -> g2:5;

   v3   -> g3:0;
   v7   -> g3:1;
   v11  -> g3:2;
   v15  -> g3:3;
   m{6} -> g3:4;
   m{7} -> g3:5;

   g0:0 -> g4:0;
   g1:1 -> g4:1;
   g2:2 -> g4:2;
   g3:3 -> g4:3;
   m{8} -> g4:4;
   m{9} -> g4:5;

   g1:0  -> g5:0;
   g2:1  -> g5:1;
   g3:2  -> g5:2;
   g0:3  -> g5:3;
   m{10} -> g5:4;
   m{11} -> g5:5;

   g2:0  -> g6:0;
   g3:1  -> g6:1;
   g0:2  -> g6:2;
   g1:3  -> g6:3;
   m{12} -> g6:4;
   m{13} -> g6:5;

   g3:0  -> g7:0;
   g0:1  -> g7:1;
   g1:2  -> g7:2;
   g2:3  -> g7:3;
   m{14} -> g7:4;
   m{15} -> g7:5;

   g4:0 -> out:0;
   g5:0 -> out:1;
   g6:0 -> out:2;
   g7:0 -> out:3;
   g7:1 -> out:4;
   g4:1 -> out:5;
   g5:1 -> out:6;
   g6:1 -> out:7;
   g6:2 -> out:8;
   g7:2 -> out:9;
   g4:2 -> out:10;
   g5:2 -> out:11;
   g5:3 -> out:12;
   g6:3 -> out:13;
   g7:3 -> out:14;
   g4:3 -> out:15;
}

module Blake(v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,va,vb,vc,vd,ve,vf){
   Blake2Round r0;
   Blake2Round r1;
   Blake2Round r2;
   Blake2Round r3;
   Blake2Round r4;
   Blake2Round r5;
   Blake2Round r6;
   Blake2Round r7;
   Blake2Round r8;
   Blake2Round r9;
#
   v0 -> r0:0;
   v1 -> r0:1;
   v2 -> r0:2;
   v3 -> r0:3;
   v4 -> r0:4;
   v5 -> r0:5;
   v6 -> r0:6;
   v7 -> r0:7;
   v8 -> r0:8;
   v9 -> r0:9;
   va -> r0:10;
   vb -> r0:11;
   vc -> r0:12;
   vd -> r0:13;
   ve -> r0:14;
   vf -> r0:15;

   r0:0..15 -> r1:0..15;
   r1:0..15 -> r2:0..15;
   r2:0..15 -> r3:0..15;
   r3:0..15 -> r4:0..15;
   r4:0..15 -> r5:0..15;
   r5:0..15 -> r6:0..15;
   r6:0..15 -> r7:0..15;
   r7:0..15 -> r8:0..15;
   r8:0..15 -> r9:0..15;

   r9:0..15 -> out:0..15;
}

module TestMemory(){
   Mem mem;
#
   mem -> out;
}

module TestVRead(){
   VRead read;
#
   read -> out;
}

module TestA(Aa,Ab,Ac,Ad){
   Const Ax;
   Const Ay;
   Const Az;
   Const Aw;
#
   Ar0 = Ax + Aa;
   Ar1 = Ay + Ab;
   Ar2 = Ac + Az;
   Ar3 = Ad + Aw;

   Ai0 = Ar0 + Ar1 + Ar2 + Ar3;
   Ai0 -> out;
}

module TestB(Ba,Bb){
   Const Bx;
   Const By;
   Muladd BmulA;
   Muladd BmulB;
#
   Ba -> BmulA:0;
   Bx -> BmulA:1;

   Bb -> BmulB:0;
   By -> BmulB:1;

   Bi0 = BmulA + BmulB;

   Bi0 -> out;
}

module TestC(Ca,Cb,Cc){
   Const Cx;
   Const Cy;
   Const Cz;
#
   Cr0 = (Ca << Cx) + (Ca << Cy) + (Ca << Cz);
   Cr1 = (Cb << Cx) + (Cb << Cy) + (Cb << Cz);
   Cr2 = (Cc << Cx) + (Cc << Cy) + (Cc << Cz);

   Cr0 -> out:0;
   Cr1 -> out:1;
   Cr2 -> out:2;
}

module TestD(Da,Db,Dc){
   Muladd DmulA;
   Muladd DmulB;
   Muladd DmulC;
   Const Dx;
   Const Dy;
   Const Dz;
#
   Da -> DmulA:0;
   Dx -> DmulA:1;

   Dr0 = DmulA + Db;

   Dr0 -> DmulB:0;
   Dy -> DmulB:1;

   Dr1 = DmulB + Dc;

   Dr1 -> DmulC:0;
   Dz -> DmulC:1;

   DmulA -> out:0;
   DmulB -> out:1;
   DmulC -> out:2;
}

module Big0(){
   Const Xx0;
   Const Xx1;
   Const Xx2;
   Const Xx3;

   TestB Xb0;
   TestB Xb1;
   TestA Xa;
#
   Xx0 -> Xb0:0;
   Xx1 -> Xb0:1;

   Xx2 -> Xb1:0;
   Xx3 -> Xb1:1;

   Xb0 -> Xa:0;
   Xb1 -> Xa:1;

   Xa -> out;
}

module Big1(){
   Const Yx0;
   Const Yx1;
   Const Yx2;

   TestC Yc0;
   TestC Yc1;
   TestD Yd;
#
   Yx0 -> Yc0:0;
   Yx1 -> Yc0:1;
   Yx2 -> Yc0:2;   

   Yc0:0 -> Yd:0;
   Yc0:1 -> Yd:1;
   Yc0:2 -> Yd:2;

   Yd:0 -> Yc1:0;
   Yd:1 -> Yc1:1;
   Yd:2 -> Yc1:2;

   Yc1:0 -> out:0;
   Yc1:1 -> out:1;
   Yc1:2 -> out:2;
}

/*
iterative Iterative_State(a){
   Reg register;  
# 1
   a -> register;
   register -> out;
#
   register -> data;
   data -> register;
   data -> out;
}

iterative Iterative_Config(){
   Const configTest;
# 1
   configTest -> out;
#
   configTest -> data;
   data -> out;
}

iterative Iterative_Databus(){
   VRead read;
# 1
   read -> out;
#
   read -> data;
   data -> out;
}
*/

module Merge0(){
   Const m0;
   Const m1;
   Reg output;
#
   a = m0 + m1;
   a -> output;
}

module Merge1(){
   Const M0;
   Const M1;
   Reg Output;
#
   A = M0 - M1;
   A -> Output;
}

module SimpleFU(in0,in1){
   Const constant;
   Mul mul;
   Mux4 sel;
#
   add = in0 + in1;
   sub = in0 - in1;
   {in0,in1} -> mul:0..1;

   {add,sub,mul,constant} -> sel:0..3;

   sel -> out;
}

module IOFU(in0){
   VRead vread;
   VWrite vwrite;
   Mem mem;
   Mux2 mux;
#
   // Circuit output
   in0 -> vwrite;
   in0 -> mem:0;

   // Circuit input
   vread -> mux:0;
   mem:0 -> mux:1;

   mux -> out;
}

module SelectInputFrom4(in0,in1,in2,in3){
   Mux4 mux;
#
   {in0,in1,in2,in3} -> mux:0..3;
   mux -> out:0;
}

module IOFUWithSelector(in0,in1,in2,in3){
   SelectInputFrom4 sel;
   IOFU FU;
#
   {in0,in1,in2,in3} -> sel:0..3;
   sel -> FU;
   FU -> out;
}   

module Select2From4(in0,in1,in2,in3){
   SelectInputFrom4 sel0;
   SelectInputFrom4 sel1;
#
   {in0,in1,in2,in3} -> sel0:0..3;
   {in0,in1,in2,in3} -> sel1:0..3;

   {sel0,sel1} -> out:0..1;
}

module FUWithSelector(in0,in1,in2,in3){
   Select2From4 sel;
   SimpleFU FU;
#
   {in0,in1,in2,in3} -> sel:0..3;
   sel:0..1 -> FU:0..1;
   FU -> out;
}

module LoopLayer(in0,in1,in2,in3){
   IOFUWithSelector f0;
   IOFUWithSelector f1;
   IOFUWithSelector f2;
   IOFUWithSelector f3;
#
   {in0,in1,in2,in3} -> f0:0..3;
   {in0,in1,in2,in3} -> f1:0..3;
   {in0,in1,in2,in3} -> f2:0..3;
   {in0,in1,in2,in3} -> f3:0..3;

   {f0,f1,f2,f3} -> out:0..3;
}

module Layer4(in0,in1,in2,in3){
   FUWithSelector f0;
   FUWithSelector f1;
   FUWithSelector f2;
   FUWithSelector f3;
#
   {in0,in1,in2,in3} -> f0:0..3;
   {in0,in1,in2,in3} -> f1:0..3;
   {in0,in1,in2,in3} -> f2:0..3;
   {in0,in1,in2,in3} -> f3:0..3;

   {f0,f1,f2,f3} -> out:0..3;
}

module SimpleCGRA(){
   LoopLayer loop;
   Layer4 l0;
   Layer4 l1;
   Layer4 l2;
   Layer4 l3;
#
   loop:0..3 -> l0:0..3;
   l0:0..3 -> l1:0..3;
   l1:0..3 -> l2:0..3;
   l2:0..3 -> l3:0..3;
   l3:0..3 -> loop:0..3;
}

module EXAMPLE_Variety1(x,y){
   using(VLinear) VRead read;
   using(VLinear) Mem mem;
   Const constant;
   Reg reg;
#
   c = x + y + read + mem + constant;

   c -> reg;
   c -> out;
}

module EXAMPLE_Variety2(x,y,z){
   using(VLinear) VRead read;
   using(VLinear) Mem mem;
   using(VLinear) VWrite write;
#
   total = x + y + z + read + mem;
   total -> write;
}

module DMATest(){
   Mem mem;   
#
}

module Simple(x[16],k[32]){
#
   w[0]  = x[0]  & k[0]  & k[1];
   w[1]  = x[1]  & k[2]  & k[3];
   w[2]  = x[2]  & k[4]  & k[5];
   w[3]  = x[3]  & k[6]  & k[7];
   w[4]  = x[4]  & k[8]  & k[9];
   w[5]  = x[5]  & k[10] & k[11];
   w[6]  = x[6]  & k[12] & k[13];
   w[7]  = x[7]  & k[14] & k[15];
   w[8]  = x[8]  & k[16] & k[17];
   w[9]  = x[9]  & k[18] & k[19];
   w[10] = x[10] & k[20] & k[21];
   w[11] = x[11] & k[22] & k[23];
   w[12] = x[12] & k[24] & k[25];
   w[13] = x[13] & k[26] & k[27];
   w[14] = x[14] & k[28] & k[29];
   w[15] = x[15] & k[30] & k[31];

   w[0..15] -> out:0..15;
}

module GenericLineKey(x[4],w[4],rcon){
   LookupTable #(.ADDR_W(8),.SIZE_W(8)) b[2];
   Mux2 mux[4];
#
   {x[0],x[1],x[2],x[3]} -> mux[0..3]:0; // Fourth line 
   {x[1],x[2],x[3],x[0]} -> mux[0..3]:1; // First line

   mux[0..3] -> {b[0]:0..1,b[1]:0..1};

   d[0] = b[0]:0 ^ w[0] ^ rcon;
   d[1] = b[0]:1 ^ w[1];
   d[2] = b[1]:0 ^ w[2];
   d[3] = b[1]:1 ^ w[3];

   d[0..3] -> out:0..3;
}

module GenericKeySchedule256(x[16],w[16],rcon){
   GenericLineKey s;
#
   {x[12],x[13],x[14],x[15]} -> s:0..3;
   {w[0],w[1],w[2],w[3]}     -> s:4..7;
   rcon -> s:8;

   a[0] = s:0 ^ w[4];
   a[1] = s:1 ^ w[5];
   a[2] = s:2 ^ w[6];
   a[3] = s:3 ^ w[7];

   b[0] = a[0] ^ w[8];
   b[1] = a[1] ^ w[9];
   b[2] = a[2] ^ w[10];
   b[3] = a[3] ^ w[11];

   c[0] = b[0] ^ w[12];
   c[1] = b[1] ^ w[13];
   c[2] = b[2] ^ w[14];
   c[3] = b[3] ^ w[15];

   s:0..3  -> out:0..3;
   a[0..3] -> out:4..7;
   b[0..3] -> out:8..11;
   c[0..3] -> out:12..15;
}

module AESFirstAdd(x[16],k[16],iv[16]){
   AddRoundKey addKey;
   AddRoundKey addKey2;
#
   x[0..15] -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> addKey2:0..15;
   iv[0..15]    -> addKey2:16..31;

   addKey2:0..15 -> out:0..15;
}

module AESInvFirstAdd(x[16],k[16],iv[16]){
   AddRoundKey addKey;
#
   x[0..15] -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> out:0..15;
}

module AESRound(x[16],k[16],iv[16]){
   SBoxGroup subBytes;
   ShiftRows shiftRows;
   MixColumns mixColumns;
   AddRoundKey addKey;
#   
   x[0..15] -> subBytes:0..15;
   subBytes:0..15 -> shiftRows:0..15;
   shiftRows:0..15 -> mixColumns:0..15;
   mixColumns:0..15 -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> out:0..15;
}

module AESInvRound(x[16],k[16],iv[16]){
   InvShiftRows invShiftRows;
   RSBoxGroup subBytes;
   AddRoundKey addKey;
   InvMixColumns invMixColumns;
#
   x[0..15] -> invShiftRows:0..15;
   invShiftRows:0..15 -> subBytes:0..15;
   subBytes:0..15 -> addKey:0..15;
   k[0..15] -> addKey:16..31;

   addKey:0..15 -> invMixColumns:0..15;

   invMixColumns:0..15 -> out:0..15;
}

module AESLastRound(x[16],key[16],iv[16]){
   SBoxGroup subBytes;
   ShiftRows shiftRows;
   AddRoundKey addKeyGood;
#
   x[0..15] -> subBytes:0..15;
   subBytes:0..15 -> shiftRows:0..15;
   shiftRows:0..15 -> addKeyGood:0..15;

   key[0..15] -> addKeyGood:16..31; 

   addKeyGood:0..15 -> out:0..15;
}

module AESInvLastRound(x[16],key[16],iv[16]){
   InvShiftRows invShiftRows;
   RSBoxGroup subBytes;
   AddRoundKey addKey;
   AddRoundKey removeIv;
#
   x[0..15] -> invShiftRows:0..15;
   invShiftRows:0..15 -> subBytes:0..15;

   subBytes:0..15 -> addKey:0..15;
   key[0..15]     -> addKey:16..31; 

   addKey:0..15 -> removeIv:0..15;
   iv[0..15]    -> removeIv:16..31;

   removeIv:0..15 -> out:0..15;
}

merge FullAESRounds = AESFirstAdd | AESRound | AESLastRound | AESInvFirstAdd | AESInvRound | AESInvLastRound;

module McEliece(){
   ReadWriteMem mat;
   VRead row;
   VWrite writer;
   Const mask;
#
   a = row & mask;
   b = mat ^ a;

   c = mat & mask;
   d = row ^ c;

   b -> mat;
   d -> writer;
}

// When we flatten FullAES, we can save the mappings.
// If round.x gets mapped to state.0 then we can save that mapping.
// Meaning that can potentially have a mapping of the sub units to the upper flattened units.
// Basically map the special inputs and outputs of a submerged graph to the upper units.

// How do we handle repeated units?
// If a module contains units of the same type A and B.
//   We are gonna have repeated mappings of the specials from A and the specials from B.
//   We need to save the name of the upper unit.
//     Techically only need to known the name, since we can then use the same function that we currently have to map nodes.

// We need to be able to map round.x0 to state:0, round.x1 to state:1 and so on.

module FullAES(){
   share(config) RegFile{
      key[16];
   }
   share(config) Reg{
      state[16];
   }
   share(config) Reg{
      lastResult[16];
   }
   share(config) Reg{
      lastValToAdd[16];
   }

   GenericKeySchedule256 schedule;
   Const rcon;
   FullAESRounds round;
   AddRoundKey lastAdd;
#
   key[0..15]:1 -> schedule:0..15;
   key[0..15]:0 -> schedule:16..31;
   rcon         -> schedule:32;

   schedule:0..15 -> key[0..15];

   state[0..15] -> round:0..15;
   key[0..15]   -> round:16..31;
   lastResult[0..15] -> round:32..47;

   round:0..15 -> lastAdd:0..15;
   lastValToAdd[0..15] -> lastAdd:16..31;

   lastAdd:0..15 -> state[0..15];
   lastAdd:0..15 -> lastResult[0..15];
}

module CryptoAlgos(){
   FullAES aes;
   SHA sha;
   McEliece eliece;
#
}

addressGen BadType(){
   addr = 1;
}

addressGen MissingVarDecl(){
   for x 0..missingVar
   addr = missingVar + y;
}

addressGen OvershadowVariable(x){
   for x 0..2
   addr = x;
}

module ADDRESSGEN_BadSyntax(){
   using(MissingVarDecl,BadType,OvershadowVariable) Generator gen;
#
}

addressGen TestAddressGen(xMax,yMax,zMax,wMax,bMax){
   for b 0..bMax
   for w 0..wMax
   for z 0..zMax
   for y 0..yMax
   for x 0..xMax
   addr = y * yMax + x;
}

module ADDRESSGEN_Simple(){
   using(VLinear,VDouble) Generator gen;
   using(VLinear,VDouble) VWrite output;
#
   gen -> output;
}

module ADDRESSGEN_Moderate(){
   using(TestAddressGen) Generator gen;
   using(VLinear) Mem output;
#
   gen -> output;
}

module ADDRESSGEN_Mem(){
   using(VLinear) Mem start;
   using(VLinear) Mem end;
#
   start:0 -> end:0;
}

addressGen Strided2(sizeX,sizeY,width,stride){
   for y 0..sizeY
   for x 0..sizeX
   addr = (y * width + x) / stride;
}

addressGen StridedLinear(size,stride){
   for x 0..size
   addr = x / stride;
}

addressGen Compared(sizeX,sizeY,width){
   for y 0..sizeY
   for x 0..sizeX
   addr = y * width + x;
}

module ADDRESSGEN_Stride(){
   using(StridedLinear) Mem mem;
   using(StridedLinear,Strided2,Compared) VWrite write;
   using(TestAddressGen) Generator gen;
#
   gen -> mem;
   gen -> write;
}

addressGen SimpleMem(length){
   for x 0..length
   addr = x;
}

// Not having a constant for the first term
addressGen AddressGenAdvanced2(){
   for z 0..2
   for y 0..2
   for x 0..2
   addr = x + 5 * y + 11 * z;
}

// Same memory can be accessed multiple times 
addressGen AddressGenAdvanced3(){
   for y 0..2 
   for x 0..2 
   addr = 2 * x + y;
}

// Same memory can be accessed multiple times 
addressGen AddressGenAdvanced31(){
   for y 0..2 
   for x 0..3 
   addr = 2 * x + y;
}

// What happens if we add a free term? 
addressGen AddressGenAdvanced32(){
   for y 0..2 
   for x 0..3 
   addr = 2 * x + y + 20;
}

// A single loop but the innermost variable is not a constant
addressGen AddressGenAdvanced33(){
   for x 0..4 
   addr = 2 * x;
}

// A single loop with a constant
addressGen AddressGenAdvanced34(a){
   for x 0..a
   addr = 2 * x;
}

// Two loops with a constant
addressGen AddressGenAdvanced4(a){
   for y 0..2
   for x 0..a
   addr = 2 * x + 5 * y;
}

// Two loops but the constant is replaced by a literal.
addressGen AddressGenAdvanced41(a){
   for y 0..2
   for x 0..5
   addr = 2 * x + 5 * y;
}

// If the constant of the first loop is large enough, what happens?
addressGen AddressGenAdvanced42(a){
   for y 0..2
   for x 0..5
   addr = 1000 * x + 5 * y;
}

addressGen AddressGenAdvanced5(a,b,c,d){
   for y 0..2
   for x 0..a
   addr = 2 * a * b * x + 5 * (c + 1) * y + d + 2 * (3 + d * x);
}

addressGen AddressGenAdvancedTest(var1,var2,var3,var4){
   for y 0..var1
   for x 0..var2
   addr = var3 * x + var4 * y;
}

addressGen AddressGenAdvancedTestSimple(){
   for y 0..2
   for x 0..4
   addr = 2 * x + 5 * y;
}


// A simple multiloop address gen where the constants of each term "guarantee" that incremental memory is being accessed.
addressGen AddressGenAdvanced(){
   for a 0..2
   for w 0..2
   for z 0..2
   for y 0..2
   for x 0..2
   addr = 2 * x + 5 * y + 11 * z + 20 * w + 3 * a;
}

addressGen AddressGenAdvancedAllVariables(var1,var2,var3,var4,var5){
   for a 0..2
   for w 0..2
   for z 0..2
   for y 0..2
   for x 0..2
   addr = var1 * x + var2 * y + var3 * z + var4 * w + var5 * a;
}

addressGen AddressGenAdvancedAllVariablesAndLoops(var1,var2,var3,var4,var5){
   for a 0..var5
   for w 0..var4
   for z 0..var3
   for y 0..var2
   for x 0..var1
   addr = var1 * x + var2 * y + var3 * z + var4 * w + var5 * a;
}

module ADDRESSGEN_Advanced(){
   using(AddressGenAdvancedTest) VRead read;
   using(VLinear) Mem output;
#
   read -> output;
}

addressGen AddressGenConstant(var1){
   for x 0..5
   addr = x + var1 + 5;
}

module ADDRESSGEN_Constants(){
   using(AddressGenConstant) VRead read;
   using(VLinear) Mem output;
#
   read -> output;
}

addressGen AddressGenEmptyLoops(){
   for y 0..2
   for x 0..2
   for empty 0..2
   addr = 2 * x + 5 * y;
}

addressGen AddressGenEmptyLoops2(){
   for y 0..2
   for empty 0..2
   for x 0..2
   addr = 2 * x + 5 * y;
}

addressGen AddressGenEmptyLoops3(){
   for empty 0..2
   for y 0..2
   for x 0..2
   addr = 2 * x + 5 * y;
}

addressGen AddressGenEmptyLoops4(){
   for t 0..4
   for x 0..5
   addr = t;
}

module ADDRESSGEN_EmptyLoops(){
   using(AddressGenEmptyLoops,AddressGenEmptyLoops2,AddressGenEmptyLoops3,AddressGenEmptyLoops4) VRead read;
   using(VLinear) Mem output;
#
   read -> output;
}

addressGen AddressGenComplexLoopExpression(var1,var2){
   for x 0..(var1 / var2)
   addr = x;
}

module ADDRESSGEN_ComplexLoopExpression(){
   using(AddressGenComplexLoopExpression) VRead read;
   using(VLinear) Mem output;
#
   read -> output;
}

addressGen TooManyLoops(){
   for h 0..2
   for g 0..2
   for f 0..2
   for e 0..2
   for d 0..2
   for c 0..2
   for b 0..2
   for a 0..2
   for z 0..2
   for y 0..2
   for x 0..2
   addr = x + y + z + a + b + c + d + e + f + g + h;
}

module ADDRESSGEN_TooManyLoops(){
   using(TooManyLoops) VRead read;
   Mem output;
#
   read -> output;
}

addressGen FullUsage(extraLoops,xWidth,xLoop,yWidth,yLoop,zWidth,aWidth,bWidth){
   for e 0..extraLoops
   for b 0..bWidth
   for a 0..aWidth
   for z 0..zWidth
   for y 0..yLoop
   for x 0..xLoop
   addr = (((b * aWidth + a) * zWidth + z) * yWidth + y) * xWidth + x;
}

addressGen Full(){
   for e 0..4
   for b 0..1
   for a 0..1
   for z 0..1
   for y 0..1
   for x 0..1
   addr = x;
}

module ADDRESSGEN_SimulateLoop(){
   using(VDouble,FullUsage,Full) VRead read;
#
}

module FullShare(){
   share(config) Const{
      unitsX[3];
   }
   Reg output[3]; 
#
   unitsX[0..2] -> output[0..2];
}

module SomeShare(){
   share(config) Const{
      unitsY[2];
   }
   Const nonShared;
   Reg output[3]; 
#
   unitsY[0..1] -> output[0..1];
   nonShared -> output[2];
}

module NoShare(){
   Const unitsZ[3];
   Reg output[3]; 
#
   unitsZ[0..2] -> output[0..2];
}

merge ADDRESSGEN_MERGE_MergeWithAddress = ADDRESSGEN_Advanced | ADDRESSGEN_ComplexLoopExpression;

merge MERGE_CONFIG_Share = FullShare | SomeShare | NoShare;

module CONFIG_ADDRESSGEN_PartialSharing(){
   using(VLinear) share(config) VRead(ext_addr){
      read[2];
   }
   /* using(SimpleMem) */ Mem output;
#
   read[0] -> output:0;
   read[1] -> output:1;
}

merge MERGE_CONFIG_ADDRESSGEN_MaxComplexity = CONFIG_ADDRESSGEN_PartialSharing | ADDRESSGEN_Simple;

//merge GoodCryptoAlgos = SHA | McEliece | FullAES;

//merge CryptoAlgos = SHA | AES256 | McEliece;
